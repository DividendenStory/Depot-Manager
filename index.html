import React, { useState, useEffect, useMemo, useCallback } from 'react';
import ReactDOM from 'react-dom/client';
import "https://cdn.tailwindcss.com";

// Haupt-App-Komponente
const App = () => {
  // Zustand für Transaktionen und Dividenden
  const [transactions, setTransactions] = useState([]);
  const [dividends, setDividends] = useState([]);
  // Zustand für aktuelle Aktienkurse und Ladeanzeige
  const [currentPrices, setCurrentPrices] = useState({});
  const [loadingPrices, setLoadingPrices] = useState(false);

  // Zustand für den Benutzernamen und den Bearbeitungsmodus
  const [username, setUsername] = useState('');
  const [tempUsername, setTempUsername] = useState('');
  const [isEditingUsername, setIsEditingUsername] = useState(false);

  // --- Lokale Datenverwaltung mit localStorage ---

  // Lade den Benutzernamen beim ersten Laden der App
  useEffect(() => {
    const savedUsername = localStorage.getItem('portfolioUsername');
    if (savedUsername) {
      setUsername(savedUsername);
      setTempUsername(savedUsername);
    }
  }, []);

  // Lade Portfoliodaten, wenn sich der Benutzername ändert
  useEffect(() => {
    if (username) {
      try {
        const savedTransactions = localStorage.getItem(`transactions_${username}`);
        if (savedTransactions) {
          setTransactions(JSON.parse(savedTransactions));
        } else {
          setTransactions([]);
        }

        const savedDividends = localStorage.getItem(`dividends_${username}`);
        if (savedDividends) {
          setDividends(JSON.parse(savedDividends));
        } else {
          setDividends([]);
        }
      } catch (error) {
        console.error("Fehler beim Laden der Daten aus localStorage", error);
      }
    }
  }, [username]);

  // Speichere Transaktionen und Dividenden bei jeder Änderung
  useEffect(() => {
    if (username) {
      localStorage.setItem(`transactions_${username}`, JSON.stringify(transactions));
    }
  }, [transactions, username]);

  useEffect(() => {
    if (username) {
      localStorage.setItem(`dividends_${username}`, JSON.stringify(dividends));
    }
  }, [dividends, username]);

  // Funktion zum Speichern des Benutzernamens
  const handleSetUsername = () => {
    if (tempUsername) {
      setUsername(tempUsername);
      localStorage.setItem('portfolioUsername', tempUsername);
      setIsEditingUsername(false);
    }
  };

  // --- API-Aufruf für Kursabfrage (Simuliert) ---
  const fetchPrices = useCallback(async () => {
    if (!username || transactions.length === 0) return;
    setLoadingPrices(true);

    const uniqueTickers = [...new Set(transactions.map(t => t.ticker))];
    if (uniqueTickers.length === 0) {
      setLoadingPrices(false);
      return;
    }

    try {
      // Simulierter Fetch-Aufruf mit einer Verzögerung von 1.5 Sekunden
      const response = await new Promise(resolve => setTimeout(() => {
        const prices = uniqueTickers.reduce((acc, ticker) => {
          // Generiere neue Preise basierend auf den alten, um die Simulation realistischer zu machen
          const existingPrice = currentPrices[ticker] || Math.random() * 100 + 50;
          const newPrice = existingPrice + (Math.random() * 5 - 2.5); // +- 2.5
          acc[ticker] = parseFloat(newPrice.toFixed(2));
          return acc;
        }, {});
        resolve({ json: () => Promise.resolve(prices) });
      }, 1500));

      const prices = await response.json();
      setCurrentPrices(prices);
    } catch (error) {
      console.error("Fehler beim Abrufen der Kurse:", error);
      setCurrentPrices(prev => prev || {});
    } finally {
      setLoadingPrices(false);
    }
  }, [transactions, currentPrices, username]);

  // Rufe die Preise beim ersten Laden und bei jeder Transaktionsänderung ab
  useEffect(() => {
    if (username) {
      fetchPrices();
      const intervalId = setInterval(fetchPrices, 60000); // Aktualisiere Kurse jede Minute
      return () => clearInterval(intervalId);
    }
  }, [fetchPrices, username]);

  // --- Berechnung der Portfoliodaten (Memoisiert) ---
  const portfolioData = useMemo(() => {
    const holdings = {};
    const transactionHistory = {};

    transactions.forEach(tx => {
      if (!holdings[tx.ticker]) {
        holdings[tx.ticker] = { quantity: 0, cost: 0, fifoLots: [] };
        transactionHistory[tx.ticker] = [];
      }
      transactionHistory[tx.ticker].push(tx);
    });

    // Sortiere Transaktionen nach Datum, um FIFO-Logik zu ermöglichen
    Object.keys(transactionHistory).forEach(ticker => {
      transactionHistory[ticker].sort((a, b) => new Date(a.date) - new Date(b.date));
    });

    Object.keys(transactionHistory).forEach(ticker => {
      let fifoLots = [];
      transactionHistory[ticker].forEach(tx => {
        if (tx.type === 'Kauf') {
          fifoLots.push({ date: tx.date, quantity: tx.quantity, price: tx.price });
        } else if (tx.type === 'Verkauf') {
          let sharesToSell = tx.quantity;
          while (sharesToSell > 0 && fifoLots.length > 0) {
            const oldestLot = fifoLots[0];
            if (sharesToSell >= oldestLot.quantity) {
              sharesToSell -= oldestLot.quantity;
              fifoLots.shift();
            } else {
              oldestLot.quantity -= sharesToSell;
              sharesToSell = 0;
            }
          }
        }
      });
      
      const remainingCost = fifoLots.reduce((acc, lot) => acc + lot.quantity * lot.price, 0);
      const remainingShares = fifoLots.reduce((acc, lot) => acc + lot.quantity, 0);

      holdings[ticker] = {
        quantity: remainingShares,
        cost: remainingShares > 0 ? remainingCost / remainingShares : 0,
        fifoLots
      };
    });

    let totalPortfolioValue = 0;
    let totalPortfolioCost = 0;
    let totalGainLoss = 0;

    Object.keys(holdings).forEach(ticker => {
      const holding = holdings[ticker];
      const currentPrice = currentPrices[ticker] || 0;
      const value = holding.quantity * currentPrice;
      const gainLoss = value - (holding.quantity * holding.cost);
      
      holding.value = value;
      holding.gainLoss = gainLoss;
      holding.gainLossPercent = holding.quantity > 0 ? (gainLoss / (holding.quantity * holding.cost)) * 100 : 0;
      holding.currentPrice = currentPrice;

      totalPortfolioValue += value;
      totalPortfolioCost += holding.quantity * holding.cost;
      totalGainLoss += gainLoss;
    });

    const totalDividends = dividends.reduce((sum, d) => sum + d.amount, 0);
    const totalGainLossWithDividends = totalGainLoss + totalDividends;
    const totalGainLossPercentWithDividends = totalPortfolioCost > 0
      ? (totalGainLossWithDividends / totalPortfolioCost) * 100
      : 0;

    return {
      holdings,
      totalPortfolioValue,
      totalPortfolioCost,
      totalGainLoss: totalGainLossWithDividends,
      totalGainLossPercent: totalGainLossPercentWithDividends,
      totalDividends
    };
  }, [transactions, dividends, currentPrices]);

  // --- UI-Komponenten und Logik ---
  const [ticker, setTicker] = useState('');
  const [quantity, setQuantity] = useState('');
  const [price, setPrice] = useState('');
  const [type, setType] = useState('Kauf');
  const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

  const [dividendTicker, setDividendTicker] = useState('');
  const [dividendAmount, setDividendAmount] = useState('');
  const [dividendDate, setDividendDate] = useState(new Date().toISOString().split('T')[0]);

  const handleAddTransaction = (e) => {
    e.preventDefault();
    if (!ticker || !quantity || !price || !date || !username) return;
    setTransactions(prev => [...prev, {
      id: Date.now(),
      ticker,
      quantity: parseFloat(quantity),
      price: parseFloat(price),
      type,
      date
    }]);
    setTicker('');
    setQuantity('');
    setPrice('');
    setDate(new Date().toISOString().split('T')[0]);
  };

  const handleAddDividend = (e) => {
    e.preventDefault();
    if (!dividendTicker || !dividendAmount || !dividendDate || !username) return;
    setDividends(prev => [...prev, {
      id: Date.now(),
      ticker: dividendTicker,
      amount: parseFloat(dividendAmount),
      date: dividendDate
    }]);
    setDividendTicker('');
    setDividendAmount('');
    setDividendDate(new Date().toISOString().split('T')[0]);
  };

  // UI-Layout
  return (
    <div className="bg-gray-50 min-h-screen font-sans antialiased text-gray-800">
      <div className="container mx-auto p-4 sm:p-6 lg:p-8">
        <h1 className="text-4xl font-extrabold mb-2 text-center text-indigo-700">Portfolio Manager</h1>
        <div className="text-lg text-center text-gray-600 mb-8 flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-2">
            <span className="shrink-0">Portfolio von:</span>
            {isEditingUsername ? (
                <div className="flex space-x-2">
                    <input
                        type="text"
                        value={tempUsername}
                        onChange={(e) => setTempUsername(e.target.value)}
                        placeholder="Benutzername"
                        className="form-input text-base py-1 px-2 w-48 sm:w-auto"
                        required
                    />
                    <button onClick={handleSetUsername} className="bg-indigo-600 text-white p-2 rounded-lg text-sm font-semibold hover:bg-indigo-700 transition-colors">
                        Speichern
                    </button>
                </div>
            ) : (
                <div className="flex items-center space-x-2">
                    <span className="font-semibold text-indigo-700">{username || 'Kein Benutzername'}</span>
                    <button onClick={() => setIsEditingUsername(true)} className="text-indigo-600 hover:text-indigo-800 text-sm font-medium">
                        (Ändern)
                    </button>
                </div>
            )}
        </div>

        {/* Portfolio-Analyse-Dashboard */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
          <Card title="Gesamtwert" value={portfolioData.totalPortfolioValue} type="currency" />
          <Card title="Gesamtkosten (FIFO)" value={portfolioData.totalPortfolioCost} type="currency" />
          <Card title="Gewinn / Verlust" value={portfolioData.totalGainLoss} type="currency" />
          <Card title="Gewinn / Verlust (%)" value={portfolioData.totalGainLossPercent} type="percent" />
          <Card title="Gesamt-Dividenden" value={portfolioData.totalDividends} type="currency" />
        </div>

        {/* Aktien-Portfolio-Tabelle */}
        <Section title="Aktien-Portfolio">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-100">
              <tr>
                <TableHeader>Ticker</TableHeader>
                <TableHeader>Aktien (Stück)</TableHeader>
                <TableHeader>Einstandskurs (FIFO)</TableHeader>
                <TableHeader>Aktueller Kurs {loadingPrices && <span className="ml-2 animate-spin">🔄</span>}</TableHeader>
                <TableHeader>Wert</TableHeader>
                <TableHeader>Gewinn / Verlust</TableHeader>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Object.keys(portfolioData.holdings).map(ticker => {
                const holding = portfolioData.holdings[ticker];
                if (holding.quantity <= 0) return null;
                return (
                  <tr key={ticker}>
                    <TableCell>{ticker}</TableCell>
                    <TableCell>{holding.quantity.toFixed(2)}</TableCell>
                    <TableCell>{formatCurrency(holding.cost)}</TableCell>
                    <TableCell>{formatCurrency(holding.currentPrice)}</TableCell>
                    <TableCell>{formatCurrency(holding.value)}</TableCell>
                    <TableCell>
                      <span className={holding.gainLoss >= 0 ? 'text-green-600' : 'text-red-600'}>
                        {formatCurrency(holding.gainLoss)} ({holding.gainLossPercent.toFixed(2)}%)
                      </span>
                    </TableCell>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </Section>

        {/* Transaktionen- und Dividenden-Formulare */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <Section title="Transaktion hinzufügen">
            <form onSubmit={handleAddTransaction} className="space-y-4">
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Ticker</label>
                <input type="text" value={ticker} onChange={(e) => setTicker(e.target.value.toUpperCase())}
                  className="form-input" placeholder="z.B. AAPL" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Datum</label>
                <input type="date" value={date} onChange={(e) => setDate(e.target.value)}
                  className="form-input" required />
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div className="flex flex-col">
                  <label className="text-sm font-medium mb-1">Stückzahl</label>
                  <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)}
                    className="form-input" step="0.01" required min="0.01" />
                </div>
                <div className="flex flex-col">
                  <label className="text-sm font-medium mb-1">Preis pro Stück</label>
                  <input type="number" value={price} onChange={(e) => setPrice(e.target.value)}
                    className="form-input" step="0.01" required min="0.01" />
                </div>
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Typ</label>
                <select value={type} onChange={(e) => setType(e.target.value)}
                  className="form-select">
                  <option>Kauf</option>
                  <option>Verkauf</option>
                </select>
              </div>
              <button type="submit" className="button-primary w-full">Transaktion speichern</button>
            </form>
          </Section>

          <Section title="Dividende hinzufügen">
            <form onSubmit={handleAddDividend} className="space-y-4">
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Ticker</label>
                <input type="text" value={dividendTicker} onChange={(e) => setDividendTicker(e.target.value.toUpperCase())}
                  className="form-input" placeholder="z.B. AAPL" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Datum</label>
                <input type="date" value={dividendDate} onChange={(e) => setDividendDate(e.target.value)}
                  className="form-input" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Betrag (€)</label>
                <input type="number" value={dividendAmount} onChange={(e) => setDividendAmount(e.target.value)}
                  className="form-input" step="0.01" required min="0.01" />
              </div>
              <button type="submit" className="button-primary w-full">Dividende speichern</button>
            </form>
          </Section>
        </div>

        {/* Historische Transaktionen und Dividenden */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <Section title="Transaktionshistorie">
            <div className="max-h-96 overflow-y-auto">
              {transactions.length === 0 ? (
                <p className="text-center text-gray-500">Keine Transaktionen vorhanden.</p>
              ) : (
                <ul className="space-y-2">
                  {transactions.sort((a, b) => new Date(b.date) - new Date(a.date)).map(tx => (
                    <li key={tx.id} className={`flex justify-between items-center p-3 rounded-lg shadow-sm ${tx.type === 'Kauf' ? 'bg-indigo-50' : 'bg-red-50'}`}>
                      <div className="flex-1">
                        <p className="font-bold text-sm">{tx.ticker}</p>
                        <p className="text-xs text-gray-600">{new Date(tx.date).toLocaleDateString()}</p>
                      </div>
                      <div className="text-right">
                        <p className={`font-medium ${tx.type === 'Kauf' ? 'text-indigo-600' : 'text-red-600'}`}>
                          {tx.type === 'Kauf' ? '+' : '-'} {tx.quantity} Stück @ {formatCurrency(tx.price)}
                        </p>
                        <p className="text-sm text-gray-700">Gesamt: {formatCurrency(tx.quantity * tx.price)}</p>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </Section>

          <Section title="Dividendenhistorie">
            <div className="max-h-96 overflow-y-auto">
              {dividends.length === 0 ? (
                <p className="text-center text-gray-500">Keine Dividenden vorhanden.</p>
              ) : (
                <ul className="space-y-2">
                  {dividends.sort((a, b) => new Date(b.date) - new Date(a.date)).map(d => (
                    <li key={d.id} className="flex justify-between items-center p-3 rounded-lg shadow-sm bg-green-50">
                      <div className="flex-1">
                        <p className="font-bold text-sm">{d.ticker}</p>
                        <p className="text-xs text-gray-600">{new Date(d.date).toLocaleDateString()}</p>
                      </div>
                      <div className="text-right">
                        <p className="font-medium text-green-600">
                          {formatCurrency(d.amount)}
                        </p>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </Section>
        </div>
      </div>
    </div>
  );
};

// Hilfsfunktionen und Komponenten
const formatCurrency = (value) => {
  return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(value);
};

const formatPercent = (value) => {
  return `${value.toFixed(2)} %`;
};

// UI-Komponenten für besseres Styling
const Card = ({ title, value, type }) => (
  <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-100 transform transition-transform hover:scale-105">
    <p className="text-sm font-medium text-gray-500">{title}</p>
    <p className={`mt-1 text-3xl font-extrabold ${value >= 0 ? 'text-green-600' : 'text-red-600'}`}>
      {type === 'currency' ? formatCurrency(value) : formatPercent(value)}
    </p>
  </div>
);

const Section = ({ title, children }) => (
  <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-100">
    <h2 className="text-2xl font-bold mb-4 text-indigo-700">{title}</h2>
    {children}
  </div>
);

const TableHeader = ({ children }) => (
  <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">
    {children}
  </th>
);

const TableCell = ({ children }) => (
  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
    {children}
  </td>
);

// Tailwind-Styling-Klassen für Formularelemente
const FormStyle = () => (
  <style>
    {`
    body {
      font-family: 'Inter', sans-serif;
    }
    .form-input, .form-select {
      width: 100%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid #e5e7eb;
      background-color: #fff;
      transition: all 0.2s ease-in-out;
      font-size: 1rem;
    }
    .form-input:focus, .form-select:focus {
      border-color: #4f46e5;
      outline: none;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
    }
    .button-primary {
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      color: #fff;
      background-color: #4f46e5;
      transition: all 0.2s ease-in-out;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .button-primary:hover {
      background-color: #4338ca;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    `}
  </style>
);

// Render-Funktion, die die App im DOM mountet
const root = document.getElementById('root');
const container = document.createElement('div');
root.appendChild(container);
ReactDOM.createRoot(container).render(
  <React.StrictMode>
    <App />
    <FormStyle />
  </React.StrictMode>
);
