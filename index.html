import React, { useState, useEffect, useMemo, useCallback } from 'react';
import ReactDOM from 'react-dom/client';
// Hinweis: Die CDN-Nutzung dient hier nur zu Demonstrationszwecken in dieser Sandbox-Umgebung.
// Für die Produktion empfiehlt es sich, Tailwind als PostCSS-Plugin zu installieren.
import "https://cdn.tailwindcss.com";

// Laden der Firebase-Funktionen aus der Umgebung
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

// Globale Firebase-Imports
// Wir können diese nur einmal laden, um Syntaxfehler zu vermeiden
const { initializeApp } = window.firebase;
const { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } = window.auth;
const { getFirestore, addDoc, onSnapshot, collection } = window.firestore;


const App = () => {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);

  const [transactions, setTransactions] = useState([]);
  const [dividends, setDividends] = useState([]);

  const [currentPrices, setCurrentPrices] = useState({});
  const [loadingPrices, setLoadingPrices] = useState(false);
  const [loadingFirebase, setLoadingFirebase] = useState(true);
  const [importingData, setImportingData] = useState(false);

  // --- Firebase-Initialisierung und Authentifizierung ---
  useEffect(() => {
    if (Object.keys(firebaseConfig).length > 0) {
      try {
        const app = initializeApp(firebaseConfig);
        const firestoreDb = getFirestore(app);
        const firebaseAuth = getAuth(app);
        setDb(firestoreDb);
        setAuth(firebaseAuth);

        const signIn = async () => {
          try {
            if (initialAuthToken) {
              await signInWithCustomToken(firebaseAuth, initialAuthToken);
            } else {
              await signInAnonymously(firebaseAuth);
            }
          } catch (error) {
            console.error("Firebase Sign-In-Fehler:", error);
          }
        };

        signIn();

        const unsubscribe = onAuthStateChanged(firebaseAuth, (user) => {
          if (user) {
            setUserId(user.uid);
            console.log("Benutzer angemeldet:", user.uid);
          } else {
            console.log("Benutzer abgemeldet oder nicht authentifiziert.");
            setUserId(null);
          }
          setLoadingFirebase(false);
        });

        return () => unsubscribe();
      } catch (error) {
        console.error("Fehler bei der Firebase-Initialisierung:", error);
        setLoadingFirebase(false);
      }
    } else {
      console.log("Firebase-Konfiguration nicht verfügbar.");
      setLoadingFirebase(false);
    }
  }, []);

  // --- Daten abrufen und speichern mit Firestore ---
  useEffect(() => {
    if (!db || !userId) return;

    const userPath = `artifacts/${appId}/users/${userId}`;

    const transactionsQuery = collection(db, `${userPath}/transactions`);
    const unsubscribeTransactions = onSnapshot(transactionsQuery, (snapshot) => {
      const transactionData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setTransactions(transactionData);
    });

    const dividendsQuery = collection(db, `${userPath}/dividends`);
    const unsubscribeDividends = onSnapshot(dividendsQuery, (snapshot) => {
      const dividendData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setDividends(dividendData);
    });

    return () => {
      unsubscribeTransactions();
      unsubscribeDividends();
    };
  }, [db, userId]);

  // --- API-Aufruf für Kursabfrage (Simuliert) ---
  const fetchPrices = useCallback(async () => {
    if (!userId || transactions.length === 0) return;
    setLoadingPrices(true);

    const uniqueTickers = [...new Set(transactions.map(t => t.ticker))];
    if (uniqueTickers.length === 0) {
      setLoadingPrices(false);
      return;
    }

    try {
      const response = await new Promise(resolve => setTimeout(() => {
        const prices = uniqueTickers.reduce((acc, ticker) => {
          const existingPrice = currentPrices[ticker] || Math.random() * 100 + 50;
          const newPrice = existingPrice + (Math.random() * 5 - 2.5);
          acc[ticker] = parseFloat(newPrice.toFixed(2));
          return acc;
        }, {});
        resolve({ json: () => Promise.resolve(prices) });
      }, 1500));

      const prices = await response.json();
      setCurrentPrices(prices);
    } catch (error) {
      console.error("Fehler beim Abrufen der Kurse:", error);
      setCurrentPrices(prev => prev || {});
    } finally {
      setLoadingPrices(false);
    }
  }, [transactions, currentPrices, userId]);

  useEffect(() => {
    if (userId) {
      fetchPrices();
      const intervalId = setInterval(fetchPrices, 60000);
      return () => clearInterval(intervalId);
    }
  }, [fetchPrices, userId]);

  // --- Berechnung der Portfoliodaten (Memoisiert) ---
  const portfolioData = useMemo(() => {
    const holdings = {};
    const transactionHistory = {};

    transactions.forEach(tx => {
      if (!holdings[tx.ticker]) {
        holdings[tx.ticker] = { quantity: 0, cost: 0, fifoLots: [] };
        transactionHistory[tx.ticker] = [];
      }
      transactionHistory[tx.ticker].push(tx);
    });

    Object.keys(transactionHistory).forEach(ticker => {
      transactionHistory[ticker].sort((a, b) => new Date(a.date) - new Date(b.date));
    });

    Object.keys(transactionHistory).forEach(ticker => {
      let fifoLots = [];
      transactionHistory[ticker].forEach(tx => {
        if (tx.type === 'Kauf') {
          fifoLots.push({ date: tx.date, quantity: tx.quantity, price: tx.price });
        } else if (tx.type === 'Verkauf') {
          let sharesToSell = tx.quantity;
          while (sharesToSell > 0 && fifoLots.length > 0) {
            const oldestLot = fifoLots[0];
            if (sharesToSell >= oldestLot.quantity) {
              sharesToSell -= oldestLot.quantity;
              fifoLots.shift();
            } else {
              oldestLot.quantity -= sharesToSell;
              sharesToSell = 0;
            }
          }
        }
      });
      
      const remainingCost = fifoLots.reduce((acc, lot) => acc + lot.quantity * lot.price, 0);
      const remainingShares = fifoLots.reduce((acc, lot) => acc + lot.quantity, 0);

      holdings[ticker] = {
        quantity: remainingShares,
        cost: remainingShares > 0 ? remainingCost / remainingShares : 0,
        fifoLots
      };
    });

    let totalPortfolioValue = 0;
    let totalPortfolioCost = 0;
    let totalGainLoss = 0;

    Object.keys(holdings).forEach(ticker => {
      const holding = holdings[ticker];
      const currentPrice = currentPrices[ticker] || 0;
      const value = holding.quantity * currentPrice;
      const gainLoss = value - (holding.quantity * holding.cost);
      
      holding.value = value;
      holding.gainLoss = gainLoss;
      holding.gainLossPercent = holding.quantity > 0 ? (gainLoss / (holding.quantity * holding.cost)) * 100 : 0;
      holding.currentPrice = currentPrice;

      totalPortfolioValue += value;
      totalPortfolioCost += holding.quantity * holding.cost;
      totalGainLoss += gainLoss;
    });

    const totalDividends = dividends.reduce((sum, d) => sum + d.amount, 0);
    const totalGainLossWithDividends = totalGainLoss + totalDividends;
    const totalGainLossPercentWithDividends = totalPortfolioCost > 0
      ? (totalGainLossWithDividends / totalPortfolioCost) * 100
      : 0;

    return {
      holdings,
      totalPortfolioValue,
      totalPortfolioCost,
      totalGainLoss: totalGainLossWithDividends,
      totalGainLossPercent: totalGainLossPercentWithDividends,
      totalDividends
    };
  }, [transactions, dividends, currentPrices]);

  // --- UI-Komponenten und Logik ---
  const [ticker, setTicker] = useState('');
  const [quantity, setQuantity] = useState('');
  const [price, setPrice] = useState('');
  const [type, setType] = useState('Kauf');
  const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

  const [dividendTicker, setDividendTicker] = useState('');
  const [dividendAmount, setDividendAmount] = useState('');
  const [dividendDate, setDividendDate] = useState(new Date().toISOString().split('T')[0]);

  const handleAddTransaction = async (e) => {
    e.preventDefault();
    if (!ticker || !quantity || !price || !date || !userId || !db) return;
    
    try {
      const userPath = `artifacts/${appId}/users/${userId}`;
      await addDoc(collection(db, `${userPath}/transactions`), {
        ticker,
        quantity: parseFloat(quantity),
        price: parseFloat(price),
        type,
        date
      });
    } catch (error) {
      console.error("Fehler beim Hinzufügen der Transaktion zu Firestore:", error);
    }
    
    setTicker('');
    setQuantity('');
    setPrice('');
    setDate(new Date().toISOString().split('T')[0]);
  };

  const handleAddDividend = async (e) => {
    e.preventDefault();
    if (!dividendTicker || !dividendAmount || !dividendDate || !userId || !db) return;

    try {
      const userPath = `artifacts/${appId}/users/${userId}`;
      await addDoc(collection(db, `${userPath}/dividends`), {
        ticker: dividendTicker,
        amount: parseFloat(dividendAmount),
        date: dividendDate
      });
    } catch (error) {
      console.error("Fehler beim Hinzufügen der Dividende zu Firestore:", error);
    }
    
    setDividendTicker('');
    setDividendAmount('');
    setDividendDate(new Date().toISOString().split('T')[0]);
  };

  const handleImportData = async (event) => {
    const files = event.target.files;
    if (files.length === 0 || !userId || !db) return;

    setImportingData(true);
    const userPath = `artifacts/${appId}/users/${userId}`;

    try {
      const importPromises = Array.from(files).map(file => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = async (e) => {
            const content = e.target.result;
            const lines = content.split('\n').filter(line => line.trim() !== '');
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const dataRows = lines.slice(1);

            if (file.name.includes('transactions')) {
              for (const row of dataRows) {
                const values = row.split(',');
                if (values.length !== headers.length) continue;
                const txData = {
                  ticker: values[headers.indexOf('ticker')].toUpperCase(),
                  quantity: parseFloat(values[headers.indexOf('quantity')]),
                  price: parseFloat(values[headers.indexOf('price')]),
                  type: values[headers.indexOf('type')],
                  date: values[headers.indexOf('date')]
                };
                await addDoc(collection(db, `${userPath}/transactions`), txData);
              }
            } else if (file.name.includes('dividends')) {
              for (const row of dataRows) {
                const values = row.split(',');
                if (values.length !== headers.length) continue;
                const divData = {
                  ticker: values[headers.indexOf('ticker')].toUpperCase(),
                  amount: parseFloat(values[headers.indexOf('amount')]),
                  date: values[headers.indexOf('date')]
                };
                await addDoc(collection(db, `${userPath}/dividends`), divData);
              }
            }
            resolve();
          };
          reader.onerror = reject;
          reader.readAsText(file);
        });
      });
      await Promise.all(importPromises);
    } catch (error) {
      console.error("Fehler beim Datenimport:", error);
    } finally {
      setImportingData(false);
      event.target.value = null; // Zurücksetzen des Dateieingabefelds
    }
  };

  // UI-Layout
  if (loadingFirebase) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-50">
        <p className="text-xl text-gray-700">Lade Anwendung...</p>
      </div>
    );
  }

  return (
    <div className="bg-gray-50 min-h-screen font-sans antialiased text-gray-800">
      <div className="container mx-auto p-4 sm:p-6 lg:p-8">
        <h1 className="text-4xl font-extrabold mb-2 text-center text-indigo-700">Portfolio Manager</h1>
        <div className="text-lg text-center text-gray-600 mb-8 flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-2">
            <span className="shrink-0">Portfolio von:</span>
            <span className="font-semibold text-indigo-700">{userId || 'Kein Benutzername'}</span>
        </div>

        {/* Portfolio-Analyse-Dashboard */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
          <Card title="Gesamtwert" value={portfolioData.totalPortfolioValue} type="currency" />
          <Card title="Gesamtkosten (FIFO)" value={portfolioData.totalPortfolioCost} type="currency" />
          <Card title="Gewinn / Verlust" value={portfolioData.totalGainLoss} type="currency" />
          <Card title="Gewinn / Verlust (%)" value={portfolioData.totalGainLossPercent} type="percent" />
          <Card title="Gesamt-Dividenden" value={portfolioData.totalDividends} type="currency" />
        </div>

        {/* Aktien-Portfolio-Tabelle */}
        <Section title="Aktien-Portfolio">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-100">
              <tr>
                <TableHeader>Ticker</TableHeader>
                <TableHeader>Aktien (Stück)</TableHeader>
                <TableHeader>Einstandskurs (FIFO)</TableHeader>
                <TableHeader>Aktueller Kurs {loadingPrices && <span className="ml-2 animate-spin">🔄</span>}</TableHeader>
                <TableHeader>Wert</TableHeader>
                <TableHeader>Gewinn / Verlust</TableHeader>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Object.keys(portfolioData.holdings).map(ticker => {
                const holding = portfolioData.holdings[ticker];
                if (holding.quantity <= 0) return null;
                return (
                  <tr key={ticker}>
                    <TableCell>{ticker}</TableCell>
                    <TableCell>{holding.quantity.toFixed(2)}</TableCell>
                    <TableCell>{formatCurrency(holding.cost)}</TableCell>
                    <TableCell>{formatCurrency(holding.currentPrice)}</TableCell>
                    <TableCell>{formatCurrency(holding.value)}</TableCell>
                    <TableCell>
                      <span className={holding.gainLoss >= 0 ? 'text-green-600' : 'text-red-600'}>
                        {formatCurrency(holding.gainLoss)} ({holding.gainLossPercent.toFixed(2)}%)
                      </span>
                    </TableCell>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </Section>

        {/* Transaktionen- und Dividenden-Formulare */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <Section title="Transaktion hinzufügen">
            <form onSubmit={handleAddTransaction} className="space-y-4">
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Ticker</label>
                <input type="text" value={ticker} onChange={(e) => setTicker(e.target.value.toUpperCase())}
                  className="form-input" placeholder="z.B. AAPL" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Datum</label>
                <input type="date" value={date} onChange={(e) => setDate(e.target.value)}
                  className="form-input" required />
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div className="flex flex-col">
                  <label className="text-sm font-medium mb-1">Stückzahl</label>
                  <input type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)}
                    className="form-input" step="0.01" required min="0.01" />
                </div>
                <div className="flex flex-col">
                  <label className="text-sm font-medium mb-1">Preis pro Stück</label>
                  <input type="number" value={price} onChange={(e) => setPrice(e.target.value)}
                    className="form-input" step="0.01" required min="0.01" />
                </div>
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Typ</label>
                <select value={type} onChange={(e) => setType(e.target.value)}
                  className="form-select">
                  <option>Kauf</option>
                  <option>Verkauf</option>
                </select>
              </div>
              <button type="submit" className="button-primary w-full">Transaktion speichern</button>
            </form>
          </Section>

          <Section title="Dividende hinzufügen">
            <form onSubmit={handleAddDividend} className="space-y-4">
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Ticker</label>
                <input type="text" value={dividendTicker} onChange={(e) => setDividendTicker(e.target.value.toUpperCase())}
                  className="form-input" placeholder="z.B. AAPL" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Datum</label>
                <input type="date" value={dividendDate} onChange={(e) => setDividendDate(e.target.value)}
                  className="form-input" required />
              </div>
              <div className="flex flex-col">
                <label className="text-sm font-medium mb-1">Betrag (€)</label>
                <input type="number" value={dividendAmount} onChange={(e) => setDividendAmount(e.target.value)}
                  className="form-input" step="0.01" required min="0.01" />
              </div>
              <button type="submit" className="button-primary w-full">Dividende speichern</button>
            </form>
          </Section>
        </div>
        
        {/* Datei-Import */}
        <Section title="Daten importieren">
          <div className="flex flex-col space-y-4">
            <div className="flex flex-col">
              <label className="text-sm font-medium mb-1">CSV-Dateien auswählen</label>
              <input 
                type="file" 
                multiple 
                onChange={handleImportData}
                className="form-input-file"
                disabled={importingData}
              />
            </div>
            {importingData && (
              <div className="flex items-center justify-center p-4 bg-indigo-50 rounded-lg">
                <span className="animate-spin mr-2">🔄</span>
                <p className="text-sm text-indigo-700">Daten werden importiert...</p>
              </div>
            )}
            <p className="text-sm text-gray-500 mt-2">
              Wählen Sie eine oder mehrere CSV-Dateien aus. Die Dateinamen sollten "transactions.csv" oder "dividends.csv" enthalten.
              Erforderliche Spalten:
              <ul className="list-disc list-inside mt-1">
                <li>**transactions.csv:** ticker, type, quantity, price, date</li>
                <li>**dividends.csv:** ticker, amount, date</li>
              </ul>
            </p>
          </div>
        </Section>


        {/* Historische Transaktionen und Dividenden */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <Section title="Transaktionshistorie">
            <div className="max-h-96 overflow-y-auto">
              {transactions.length === 0 ? (
                <p className="text-center text-gray-500">Keine Transaktionen vorhanden.</p>
              ) : (
                <ul className="space-y-2">
                  {transactions.sort((a, b) => new Date(b.date) - new Date(a.date)).map(tx => (
                    <li key={tx.id} className={`flex justify-between items-center p-3 rounded-lg shadow-sm ${tx.type === 'Kauf' ? 'bg-indigo-50' : 'bg-red-50'}`}>
                      <div className="flex-1">
                        <p className="font-bold text-sm">{tx.ticker}</p>
                        <p className="text-xs text-gray-600">{new Date(tx.date).toLocaleDateString()}</p>
                      </div>
                      <div className="text-right">
                        <p className={`font-medium ${tx.type === 'Kauf' ? 'text-indigo-600' : 'text-red-600'}`}>
                          {tx.type === 'Kauf' ? '+' : '-'} {tx.quantity} Stück @ {formatCurrency(tx.price)}
                        </p>
                        <p className="text-sm text-gray-700">Gesamt: {formatCurrency(tx.quantity * tx.price)}</p>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </Section>

          <Section title="Dividendenhistorie">
            <div className="max-h-96 overflow-y-auto">
              {dividends.length === 0 ? (
                <p className="text-center text-gray-500">Keine Dividenden vorhanden.</p>
              ) : (
                <ul className="space-y-2">
                  {dividends.sort((a, b) => new Date(b.date) - new Date(a.date)).map(d => (
                    <li key={d.id} className="flex justify-between items-center p-3 rounded-lg shadow-sm bg-green-50">
                      <div className="flex-1">
                        <p className="font-bold text-sm">{d.ticker}</p>
                        <p className="text-xs text-gray-600">{new Date(d.date).toLocaleDateString()}</p>
                      </div>
                      <div className="text-right">
                        <p className="font-medium text-green-600">
                          {formatCurrency(d.amount)}
                        </p>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </Section>
        </div>
      </div>
    </div>
  );
};

// Hilfsfunktionen und Komponenten
const formatCurrency = (value) => {
  return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(value);
};

const formatPercent = (value) => {
  return `${value.toFixed(2)} %`;
};

const Card = ({ title, value, type }) => (
  <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-100 transform transition-transform hover:scale-105">
    <p className="text-sm font-medium text-gray-500">{title}</p>
    <p className={`mt-1 text-3xl font-extrabold ${value >= 0 ? 'text-green-600' : 'text-red-600'}`}>
      {type === 'currency' ? formatCurrency(value) : formatPercent(value)}
    </p>
  </div>
);

const Section = ({ title, children }) => (
  <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-100">
    <h2 className="text-2xl font-bold mb-4 text-indigo-700">{title}</h2>
    {children}
  </div>
);

const TableHeader = ({ children }) => (
  <th className="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">
    {children}
  </th>
);

const TableCell = ({ children }) => (
  <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
    {children}
  </td>
);

const FormStyle = () => (
  <style>
    {`
    body {
      font-family: 'Inter', sans-serif;
    }
    .form-input, .form-select {
      width: 100%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid #e5e7eb;
      background-color: #fff;
      transition: all 0.2s ease-in-out;
      font-size: 1rem;
    }
    .form-input:focus, .form-select:focus {
      border-color: #4f46e5;
      outline: none;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
    }
    .button-primary {
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      font-weight: 600;
      color: #fff;
      background-color: #4f46e5;
      transition: all 0.2s ease-in-out;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .button-primary:hover {
      background-color: #4338ca;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    .form-input-file {
      display: block;
      width: 100%;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
      font-size: 1rem;
      line-height: 1.5;
      color: #4b5563;
    }
    `}
  </style>
);

const root = document.getElementById('root');
const container = document.createElement('div');
root.appendChild(container);
ReactDOM.createRoot(container).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

